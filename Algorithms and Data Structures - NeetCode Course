Algorithms and Data Structures - NeetCode Course

Static Arrays (fixed sized arrays)

Contiguous block of data, stored the same way in RAM
Read or Write to data

Reading a value happens in constant time O(1)

Array time complexity
r/w element O(1)
insert/remove at the end O(1)
insert middle O(n)
remove middle O(n)

Remove Duplicates From Sorted Array

class Solution:
    def removeDuplicates(self, nums: List[int]) -> int:
        # uniquenums = sorted(set(nums))
        # nums[:len(uniquenums)] = uniquenums
        # return len(uniquenums)
 
 # Two pointers method
        l = 1 # l moves only when a unique value is added to the spot its in
        for r in range(1, len(nums)):
            if nums[r] != nums[r - 1]: # r is checking if the number r is at is the same as the previous number
                nums[l] = nums[r] # if its not the same then put the value of r into the position of l
                l += 1 # because something was added to l, l can move up to the next spot
        return l # return l bc that will return the position which is what the q wants

Remove Element - Good Two pointer Template
class Solution:
    def removeElement(self, nums: List[int], val: int) -> int:
        l = 0 # set up a value to store the values were want to keep
        for r in range(len(nums)): # loop through the array as R
            if nums[r] != val: # if the number R is at does NOT equal the val we want to remove
                nums[l] = nums[r] # store that number in our l variable
                l += 1 # move l along if a value is placed in there
        return l # once R hits the boundary of the list return what was placed in l, this would be every number that is NOT the val

Dynamic Arrays
The default in Python

Array time complexity
r/w element O(1)
insert/remove at the end O(1)
insert middle O(n)
remove middle O(n)

Concatenation of Array

class Solution:
    def getConcatenation(self, nums: List[int]) -> List[int]:
        ans = []
        for i in range(2):
            for n in nums:
                ans.append(n)
    
        return ans


Stacks

Operation    Big-O Time
Push         O(1)
Pop          O(1)
Peek         O(1)

Stacks are Arrays
Top of the stack is the end
One common use case of dynamic arrays
LIFO data structure (last in, first out)

Valid Parenthesis (Very common interview question)
Uses Stacks data structure

class Solution:
    def isValid(self, s: str) -> bool:
        stack = []
        closeToOpen = {")" : "(", "]" : "[", "}" : "{"} # mapping the closing bracket to its opening bracket

        for char in s:
            if char in closeToOpen: # checks if its a closing bracket because this checks the keys of the map
                if stack and stack[-1] == closeToOpen[char]: # "if stack = checks is the stack empty" 
                # and if stack-1(one before the one were lookin at is the corresponding closing bracket)
                    stack.pop() # they match so pop off the stack
                else:
                    return False # if they dont match thats false
            else:
                stack.append(char)
        
        return True if not stack else False
                

Linked Lists
Made up of List Nodes
list nodes containt two attributes: Value, Next
Connected via pointers
Store elements in an ordered sequence

Reverse Linked List
Useful for future questions as it maybe be a small portion of other questions

# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next

class Solution:
    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:
        # Two pointer solution
        prev, curr = None, head # Set the two pointers prev at null/None and current at head
        while curr: # while current isnt null
            nxt = curr.next 
            curr.next = prev #
            prev = curr # set the previous value to the current value
            curr = nxt # then send the current value forward to get the new current value
        head = prev
        return head # prev is now the new head


Merge Two Sorted Linked Lists
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next

class Solution:
    def mergeTwoLists(self, list1: Optional[ListNode], list2: Optional[ListNode]) -> Optional[ListNode]:
        dummy = node = ListNode()

        while list1 and list2:
            if list1.val < list2.val:
                node.next = list1
                list1 = list1.next
            else:
                node.next = list2
                list2=list2.next
            node=node.next
        node.next = list1 or list2
        return dummy.next

Hash Map Exercise

Contains Duplicate
class Solution:
    def hasDuplicate(self, nums: List[int]) -> bool:
        count = {}
        for num in nums:
            if num in count:
                return True
            else:
                count[num] = 1
        return False

        # As if you want to count how many 
        # times a number occurs in your list 
        # but as soon as theres a duplicate you 
        # can return True rather than any 
        # incrementation and return False if 
        # all counts return 1 occurance

Python one liner
def hasDuplicate(self, nums: List[int]) -> bool:
    return len(nums) != len(set(nums))
       
Doubly Linked Lists

Adding a node to a doubly linked list
say we have node 1,2,3 and we are adding node 4.

tail.next = ListNode4
ListNode4.prev = tail
tail = tail.next

# the order of the above code is important

remove the node:
say we have node 1,2,3
to remove 3
instead of pointing 2 to 3 point that pointer to null. this makes it the end of the list. 
Since theres no reference to 3 now, it does not exist
Code of this operation
node2 = tail.prev # name the tails prev node, node 2
node2.next = null # make the node after node 2 null basically removing 3
tail = node2 # now 2 is the last one, name it tail.

Stacks can be implemented with linked list
can't access a random element like with arrays becuase you have to follow the nodes 
there.


class Node:
    def __init__(self, val: int):
        self.val = val
        self.next = None
        self.prev = None


class DoublyLinkedList:
    def __init__(self):
        self.head = None
        self.tail = None

    def addAtHead(self, val: int) -> None:
        newNode = Node(val)
        if not self.head:
            self.head = self.tail = newNode
        else:
            newNode.next = self.head
            self.head.prev = newNode
            self.head = newNode

    def addAtTail(self, val: int) -> None:
        newNode = Node(val)
        if not self.tail:
            self.head = self.tail = newNode
        else:
            self.tail.next = newNode
            newNode.prev = self.tail
            self.tail = newNode

    def addAtIndex(self, index: int, val: int) -> None:
        # Case 1: insert at head
        if index == 0:
            self.addAtHead(val)
            return

        newNode = Node(val)
        curr = self.head
        pos = 0

        # Move to node at position `index - 1`
        while curr and pos < index - 1:
            curr = curr.next
            pos += 1

        if not curr:  # index is out of bounds
            return

        # Case 2: insert at the end (after tail)
        if curr == self.tail:
            self.addAtTail(val)
            return

        # Case 3: insert in the middle
        newNode.next = curr.next
        newNode.prev = curr
        curr.next.prev = newNode
        curr.next = newNode

Queues

Fifo - first in first out

enqueue - add to end
dequeue - remove from front

class MyStack:

    def __init__(self):
        self.stack = deque()
        

    def push(self, x: int) -> None:
        self.stack.append(x)

    def pop(self) -> int:
        return self.stack.pop()

    def top(self) -> int:
        return self.stack[-1]

    def empty(self) -> bool:
        return len(self.stack) == 0
        


