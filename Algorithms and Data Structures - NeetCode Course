Algorithms and Data Structures - NeetCode Course

Static Arrays (fixed sized arrays)

Contiguous block of data, stored the same way in RAM
Read or Write to data

Reading a value happens in constant time O(1)

Array time complexity
r/w element O(1)
insert/remove at the end O(1)
insert middle O(n)
remove middle O(n)

Remove Duplicates From Sorted Array

class Solution:
    def removeDuplicates(self, nums: List[int]) -> int:
        # uniquenums = sorted(set(nums))
        # nums[:len(uniquenums)] = uniquenums
        # return len(uniquenums)
 
 # Two pointers method
        l = 1 # l moves only when a unique value is added to the spot its in
        for r in range(1, len(nums)):
            if nums[r] != nums[r - 1]: # r is checking if the number r is at is the same as the previous number
                nums[l] = nums[r] # if its not the same then put the value of r into the position of l
                l += 1 # because something was added to l, l can move up to the next spot
        return l # return l bc that will return the position which is what the q wants

Remove Element - Good Two pointer Template
class Solution:
    def removeElement(self, nums: List[int], val: int) -> int:
        l = 0 # set up a value to store the values were want to keep
        for r in range(len(nums)): # loop through the array as R
            if nums[r] != val: # if the number R is at does NOT equal the val we want to remove
                nums[l] = nums[r] # store that number in our l variable
                l += 1 # move l along if a value is placed in there
        return l # once R hits the boundary of the list return what was placed in l, this would be every number that is NOT the val

Dynamic Arrays
The default in Python

Array time complexity
r/w element O(1)
insert/remove at the end O(1)
insert middle O(n)
remove middle O(n)

Concatenation of Array

class Solution:
    def getConcatenation(self, nums: List[int]) -> List[int]:
        ans = []
        for i in range(2):
            for n in nums:
                ans.append(n)
    
        return ans


Stacks

Operation    Big-O Time
Push         O(1)
Pop          O(1)
Peek         O(1)

Stacks are Arrays
Top of the stack is the end
One common use case of dynamic arrays
LIFO data structure (last in, first out)

Valid Parenthesis (Very common interview question)
Uses Stacks data structure

class Solution:
    def isValid(self, s: str) -> bool:
        stack = []
        closeToOpen = {")" : "(", "]" : "[", "}" : "{"} # mapping the closing bracket to its opening bracket

        for char in s:
            if char in closeToOpen: # checks if its a closing bracket because this checks the keys of the map
                if stack and stack[-1] == closeToOpen[char]: # "if stack = checks is the stack empty" 
                # and if stack-1(one before the one were lookin at is the corresponding closing bracket)
                    stack.pop() # they match so pop off the stack
                else:
                    return False # if they dont match thats false
            else:
                stack.append(char)
        
        return True if not stack else False
                

Linked Lists
Made up of List Nodes
list nodes containt two attributes: Value, Next
Connected via pointers
Store elements in an ordered sequence

Reverse Linked List
Useful for future questions as it maybe be a small portion of other questions

# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next

class Solution:
    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:
        # Two pointer solution
        prev, curr = None, head # Set the two pointers prev at null/None and current at head
        while curr: # while current isnt null
            nxt = curr.next 
            curr.next = prev #
            prev = curr # set the previous value to the current value
            curr = nxt # then send the current value forward to get the new current value
        head = prev
        return head # prev is now the new head


Merge Two Sorted Linked Lists
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next

class Solution:
    def mergeTwoLists(self, list1: Optional[ListNode], list2: Optional[ListNode]) -> Optional[ListNode]:
        dummy = node = ListNode()

        while list1 and list2:
            if list1.val < list2.val:
                node.next = list1
                list1 = list1.next
            else:
                node.next = list2
                list2=list2.next
            node=node.next
        node.next = list1 or list2
        return dummy.next

