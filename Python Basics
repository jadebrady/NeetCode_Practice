Python Basics

Sorting

sorted(list, reversed=True, key=function eg. lambda, abs, one i wrote myself)

# sorted creates a new list leaving the original un changed

list.sort(same as above)
# sort changes the original list

Pythonic Code

unpacking

from typing import List, Tuple


def sum_3_integers(triplet: List[int]) -> int:
    n1, n2, n3 = triplet
    sumof = n1 + n2 + n3
    return sumof


def compute_volume(box_dimensions: Tuple[int, int, int]) -> int:
    b1, b2, b3 = box_dimensions
    sumof = b1 * b2 * b3 # volume of a box n x n x n
    return sumof
  

# do not modify below this line
print(sum_3_integers([1, 2, 3]))
print(sum_3_integers([4, 6, 2]))

print(compute_volume((1, 2, 3)))
print(compute_volume((3, 2, 1)))
print(compute_volume((3, 9, 7)))


Loop Unpacking

from typing import List, Tuple


def best_student(scores: List[Tuple[str, int]]) -> str:
    scores.sort(key=lambda x: x[1], reverse=True) # Getting the score index of the list
    for name, score in scores:
        return name # getting just the name to return


# do not modify below this line
print(best_student([("Alice", 90), ("Bob", 80), ("Charlie", 70)]))
print(best_student([("Alice", 90), ("Bob", 80), ("Charlie", 100)]))
print(best_student([("Alice", 90), ("Bob", 100), ("Charlie", 70)]))
print(best_student([("Alice", 90), ("Bob", 90), ("Charlie", 80), ("David", 100)]))

Enumerate
nums = [2, 7, 9, 2]

for i, n in enumerate(nums):
    print(i, n)


Zip function - Python

from typing import List, Dict


def group_names_and_scores(names: List[str], scores: List[int]) -> Dict[str, int]:
    name_score = {}
    for name, score in zip(names, scores):
        name_score[name] = score
    return name_score
        


# do not modify below this line
print(group_names_and_scores(["Alice", "Bob", "Charlie"], [90, 80, 70]))
print(group_names_and_scores(["Jane", "Carol", "Charlie"], [25, 100, 60]))
print(group_names_and_scores(["Doug", "Bob", "Tommy"], [80, 90, 100]))

Inequality
from typing import List


def is_arr_valid(names: List[str], max_length: int) -> bool:
    if 0 < len(names) <= max_length:
        return True
    return False



# do not modify below this line
print(is_arr_valid(["Alice", "Bob", "Charlie"], 3))
print(is_arr_valid(["Alice", "Bob", "Charlie"], 2))
print(is_arr_valid(["Alice", "Bob", "Charlie"], 0))
print(is_arr_valid(["Alice", "Bob", "Charlie"], 1))
print(is_arr_valid(["Alice", "Bob", "Charlie"], 4))


Resizable Lists

from typing import List


def append_elements(arr1: List[int], arr2: List[int]) -> List[int]:
    for item in arr2:
        arr1.append(item)
    return arr1


def pop_n(arr: List[int], n: int) -> List[int]:
    for i in range(n):
        if n > len(arr) - 1:
            return []
        arr.pop(len(arr)-1)
    return arr
        

def insert_at(arr: List[int], index: int, element: int) -> List[int]:
    if index > len(arr):
        arr.append(element)
    else:
        arr.insert(index, element)
    return arr


# do not modify below this line
print(append_elements([1, 2, 3], [4, 5, 6]))
print(append_elements([4, 3], [4, 5, 3]))

print(pop_n([1, 2, 3, 4, 5], 2))
print(pop_n([1, 2, 3, 4, 5], 6))
print(pop_n([1, 2, 3, 4, 5], 5))

print(insert_at([1, 2, 3, 4, 5], 2, 6))
print(insert_at([1, 2, 3, 4], 6, 5))

Resizable List 2
from typing import List


def append_elements(arr1: List[int], arr2: List[int]) -> List[int]:
    for item in arr2:
        arr1.append(item)
    return arr1
  

def remove_elements(arr1: List[int], arr2: List[int]) -> List[int]:
    for i in arr2:
        if i in arr1:
            arr1.remove(i)
    return arr1


# do not modify below this line
print(append_elements([1, 2, 3], [4, 5, 6]))
print(append_elements([4, 3], [4, 5, 3]))

print(remove_elements([1, 2, 3, 4, 5], [2, 4, 6]))
print(remove_elements([1, 2, 3, 4, 5], [2, 3, 4, 5, 5]))
print(remove_elements([1, 7, 2, 3, 4, 5], [6, 7, 8, 2]))


List Concat
from typing import List


def combine_elements(arr1: List[int], arr2: List[int]) -> List[int]:
    newlist = arr1 + arr2
    return newlist



# do not modify below this line
arr1 = [1, 3, 5]
arr2 = [4, 6, 8]

print(combine_elements(arr1, arr2))
print(arr1)
print(arr2)

List Initialisation

from typing import List


def create_list_with_value(size: int, index: int, value: int) -> List[int]:
    myList = [0] * size
    myList[index] = value
    return myList



# do not modify below this line
print(create_list_with_value(5, 3, 7))
print(create_list_with_value(1, 0, 5))
print(create_list_with_value(10, 9, 9))
print(create_list_with_value(10, 9, 0))


List Cloning
from typing import List


def remove_element(arr: List[int], element: int) -> List[int]:
    arrClone = arr.copy()
    arrClone.remove(element)
    return arrClone



# do not modify below this line
arr = [1, 3, 5, 7, 9]

print(remove_element(arr, 3))
print(arr)
print(remove_element(arr, 9))
print(arr)
print(remove_element(arr, 1))
print(arr)

List comprehension

# making a list with only odd numbers, size depending on the number n

from typing import List


def create_list_of_odds(n: int) -> List[int]:
    return [i for i in range(1, n + 1, 2)]


# do not modify below this line
print(create_list_of_odds(1))
print(create_list_of_odds(5))
print(create_list_of_odds(6))
print(create_list_of_odds(10))

Stack Push(append) and Pop

from typing import List


def reverse_list(arr: List[int]) -> List[int]:
    arr2 = []
    while len(arr) > 0:
        lastpopped = arr.pop()
        arr2.append(lastpopped)
    

    return arr2
    


# do not modify below this line
print(reverse_list([1, 2, 3]))
print(reverse_list([3, 2, 1, 4, 6, 2]))
print(reverse_list([1, 9, 7, 3, 2, 1, 4, 6, 2]))

Rotating List
Queue Deque
from typing import List, Deque
from collections import deque


def rotate_list(arr: List[int], k: int) -> Deque[int]:
    queue = deque(arr) # SET ARRAY TO DOUBLE ENDED QUEUE

    for i in range(k): # LOOP K TIMES
        first = queue.popleft() # POP OFF FIRST VALUE OF QUEUE
        queue.append(first) # APPEND FIRST VALUE TO THE END
    
    return queue # SHOW THE RESULT
   
# do not modify below this line
print(rotate_list([1, 2, 3, 4, 5], 0))
print(rotate_list([1, 2, 3, 4, 5], 1))
print(rotate_list([1, 2, 3, 4, 5], 2))
print(rotate_list([1, 2, 3, 4, 5], 3))
print(rotate_list([1, 2, 3, 4, 5], 4))
print(rotate_list([1, 2, 3, 4, 5], 5))


Deque
from typing import List, Deque
from collections import deque


def rotate_list(arr: List[int], k: int) -> Deque[int]:
    queue = deque(arr) # empty the array 
    for i in range(k):
        queue.appendleft(queue.pop())
    return queue


# do not modify below this line
print(rotate_list([1, 2, 3, 4, 5], 0))
print(rotate_list([1, 2, 3, 4, 5], 1))
print(rotate_list([1, 2, 3, 4, 5], 2))
print(rotate_list([1, 2, 3, 4, 5], 3))
print(rotate_list([1, 2, 3, 4, 5], 4))
print(rotate_list([1, 2, 3, 4, 5], 5))


Nested Lists
finding the highest number in nested lists

from typing import List


def find_max_in_each_list(nested_arr: List[List[int]]) -> List[int]:
    maxList = [] # bc we are returning a list, create empty list to store max
    for sublist in nested_arr: # loop through the sublists
        highest = max(sublist) # store the highest value of each
        maxList.append(highest) # add the highest value to the new list
    return maxList # show the list
            

# do not modify below this line
print(find_max_in_each_list([[1, 2], [3, 4, 2]]))
print(find_max_in_each_list([[1, 2, 3], [4, 5, 6], [7, 8, 9]]))
print(find_max_in_each_list([[5, 6, 2, 8], [9], [9, 10], [11, 10, 11]]))

2D maps 
from typing import List


def in_bounds(grid: List[List[int]], r: int, c: int) -> bool:
    rows = len(grid)
    cols = len(grid[0])
    if c | r > rows | cols:
        return False
    elif c | r < 0:
        return False
    else:
        return True


# do not modify below this line
print(in_bounds([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 0, 0))
print(in_bounds([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 2, 2))
print(in_bounds([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 1, 1))
print(in_bounds([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 4, 3))
print(in_bounds([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3, 4))
print(in_bounds([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3, -1))
print(in_bounds([[1, 2, 3], [4, 5, 6], [7, 8, 9]], -1, 3))


Create nested lists with list comprehension

from typing import List


def create_grid(rows: int, cols: int, value: int) -> List[List[int]]:
    grid = [[value] * cols for _ in range(rows)]
    return grid


# do not modify below this line
print(create_grid(2, 3, 0))
print(create_grid(3, 2, 1))
print(create_grid(4, 4, 4))
print(create_grid(1, 1, 5))
print(create_grid(1, 5, 5))


Zip functions for Hash Maps
from typing import List, Dict


def build_hash_map(keys: List[str], values: List[int]) -> Dict[str, int]:
    hm = {} # Create an empty hashmap
    for key, value in zip(keys, values): # Using the zip function, 
    #iterate through both keys and values lists at the same time
        hm[key] = value # add key and value at each iteration
    return hm # return the hash map
 

def get_values(hash_map: Dict[str, int], keys: List[str]) -> List[int]:
    values = [] # create new list to hold output
    for key in keys: # loop through only the keys 
        values.append(hash_map[key]) # append list with these keys values
    return values # return the list


# do not modify below this line
print(build_hash_map(["Alice", "Bob", "Charlie"], [90, 80, 70]))
print(build_hash_map(["Jane", "Carol", "Charlie"], [25, 100, 60]))
print(build_hash_map(["Doug", "Bob", "Tommy"], [80, 90, 100]))

print(get_values({"Alice": 90, "Bob": 80, "Charlie": 70}, ["Alice", "Bob", "Charlie"]))
print(get_values({"Jane": 25, "Charlie": 60, "Carol": 100, }, ["Jane", "Carol"]))
print(get_values({"X": 205, "Y": 78, "Z": 100}, ["Y"]))


Using HashMap with Defaultdict

from collections import defaultdict
from typing import List, Dict


def count_chars(s: str) -> Dict[str, int]:
    freq = defaultdict(int)
    
    for letter in s:
        freq[letter] += 1
    
    return(freq)


def nested_list_to_dict(nums: List[List[int]]) -> Dict[int, List[int]]:
    freq = defaultdict(list)  # ✅ creates a dictionary where each key maps to a list by default

    for sublist in nums:  # ✅ loop through each inner list in nums
        first = sublist[0]  # ✅ take the first element of the sublist as the key

        for i in range(1, len(sublist)):  # ⚠️ loops through the rest of the elements (skips index 0)
            freq[first].append(sublist[i])  # ✅ append each remaining element to the list for this key

    return freq



# do not modify below this line
print(count_chars("hello"))
print(count_chars("helloworld"))
print(count_chars("areallylongstringwhyareyoureadingthishahalol"))

print(nested_list_to_dict([[1, 2, 3], [4, 5, 6], [1, 4]]))
print(nested_list_to_dict([[1, 2, 3, 4], [4, 5, 6, 7], [1, 4, 5, 6]]))
print(nested_list_to_dict([[5, 2, 3, 4, 5], [4, 5, 6, 7, 8], [5, 6, 7, 8, 9]]))
print(nested_list_to_dict([[3, 2, 3, 4, 5], [4, 5, 6, 7, 8], [5, 6, 7, 8]]))
