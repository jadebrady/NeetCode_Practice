DSA Course

# Print n times (user inputted)
n = input("enter a number: ")

for i in range(int(n)):
    print("hello world")


Neetcode

Two Sum - Hash Maps and Arrays
class Solution:
    def twoSum(self, nums: List[int], target: int) -> List[int]:
        prevMap = {}  # hashmap to remember numbers we've seen (number -> index)

        # loop through the list with index (i) and number (n)
        for i, n in enumerate(nums):  #enumerate adds the index
            diff = target - n  # the number we need to find to reach the target
            
            # if the "needed number" is already in our hashmap,
            # that means we found the pair (the previous one and the current one)
            if diff in prevMap:
                return [prevMap[diff], i]  # return their indexes
            
            # otherwise, store the current number and its index in the hashmap
            prevMap[n] = i  

        # not really needed since the problem guarantees a solution,
        # but it's here for completeness
        return

Valid Anagram - Hash Maps and Arrays
class Solution:
    def isAnagram(self, s: str, t: str) -> bool:
        # if the lengths are different, they can never be anagrams
        if len(s) != len(t):
            return False

        countS, countT = {}, {}  # hashmap to count characters in s and t

        # loop through both words at the same time
        for i in range(len(s)):
            # add +1 to the count of the character in s
            countS[s[i]] = 1 + countS.get(s[i], 0)

            # add +1 to the count of the character in t
            countT[t[i]] = 1 + countT.get(t[i], 0)

        # now compare the counts of every character in s
        for c in countS:
            # if a character in s doesn't match the count in t, not an anagram
            if countS[c] != countT.get(c, 0):
                return False

        # if all counts match, it's an anagram
        return True

Other easier solution
class Solution:
    def isAnagram(self, s: str, t: str) -> bool:
        if len(s) != len(t):
            return False

        return sorted(s) == sorted(t)


Group Anagrams - Hash Maps and Arrays
def groupAnagrams(self, strs: List[str]) -> List[List[str]]:
    
    res = {}  # dictionary to store groups of anagrams
               # key = letter count signature of a word
               # value = list of words matching that signature

    for s in strs:  # loop through every word in the input list
        count = [0] * 26  # create a list of 26 zeros, one for each letter a-z
                           # count[i] will store how many times letter i appears in the word

        # count the frequency of each letter in the current word
        for c in s:
            # ord(c) - ord("a") converts letter to index: 'a' -> 0, 'b' -> 1, ..., 'z' -> 25
            # increment the count at that index
            count[ord(c) - ord("a")] += 1

        # convert the list of counts to a tuple so it can be used as a dictionary key
        # this tuple is a "signature" for the word: all anagrams will have the same signature
        key = tuple(count)

        # add the word to the group corresponding to its signature
        if key not in res:
            res[key] = []  # create a new list if this is the first word with this signature
        res[key].append(s)  # append the current word to the correct anagram group

    # return all groups of anagrams as a list of lists
    return list(res.values())

Recursion

One-Branch
n! = n* (n-1) * (n-2) *...* 1

n! = n * (n-1)!
Good for sub problems

int factorial(int n){
    if (n <= 1){
    return 1;
    }
    return n * factorial(n-1);
}

Recursive functions have two parts:

    The base case.
    The recursive case.


Recursive Solution to Reverse a Linked List

class Solution:
    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:
        if not head:
            return None

        newHead = head
        if head.next:
            newHead = self.reverseList(head.next)
            head.next.next = head
        head.next = None

        return newHead


Two-Branch

Fibonacci Number
F(n) = F(n-1) + F(n-2)
F(0) = 0 F(1) = 1
int fib(int n) {
    if(n<= 1){
    return n;
    }
    return fib(n-1)+fib(n-2);
}

Climbing Stairs
class Solution:
    def climbStairs(self, n: int) -> int:
        if n <= 2:
            return n
        return self.climbStairs(n-1) + self.climbStairs(n-2)

This recursive solution works but it is so slow and cant go past 44 as the test case. Valid just too slow


Insertion Sorting

sudo code

for (i from 1 to arr.length){
    j = i - 1
    while j > - 0 and arr[j +1]< arr[j]{
    tmp = arr[j+ 1]
    arr[j + 1] = arr[j]
    arr[j] = tmp
    j = -1
    }
}

Stable vs Non-Stable Sorting
Stable maintains the original order of duplicated number in the new sorted array.

7,3,7
sorted to 3, first 7 from last list, second 7 from last list

Bubble code sudo code
procedure bubbleSort(A):
    n ← length(A)
    for i from 0 to n - 1:
        swapped ← false
        for j from 0 to n - i - 2:
            if A[j] > A[j + 1]:
                swap A[j], A[j + 1]
                swapped ← true
        if swapped = false:
            break   // list already sorted

Linear Search sudo code

Linear Search just finding a target n using a for loop
procedure linearSearch(A, target):
    for i from 0 to length(A) - 1:
        if A[i] = target:
            return i   // index found
    return -1          // not found

Find target integer in array and return index:
my Solution:

class Solution:
    def search(self, nums: List[int], target: int) -> int:
        for e, i in enumerate(nums):
            if target == i:
                return e
        return -1


Binary Trees
have nodes like linked lists
uses pointers to connect them together
similar to doubly linked list nodes
left and right pointer
nodes have parent child relationship. top ones are parents lower are children
if  a node has no children its considered a leaf node
top node is called the root node
only one root and can have multiple leaf nodes.
not allowed cycles
all nodes must have connections
height property - height of single node is 1
a descedant is any node thats under it
ancestor opposite anything above

Binary Search Tree (BST)
have a sorted property
BST dont have duplicates usually
right sub tree values must be higher than the root and left sub tree values must be lower than the root

def search(root, target):
if not root:
return false

if target > root.val:
    return search(root.right, target)
elif target < root.val:
    return search(root.left, target)
else:
    return True

BST Insert

def insert(root, val):
    if not root:
        return TreeNode(val)
    if val > root.val:
        root.right = insert(root.right, val)
    elif val < root.val:
        root.left = insert(root.left, val)
    return root


find min - go down the left

def minValue(root):
curr= root
while curr and curr.left:
    curr = curr.left
return curr

max would be the same but going right

Remove function

def remove(root,val):
if not root:
    return None

if val > root.val:
    root.right = remove(root.right, val)
elif val < root.val:
    root.left = remove(root.left, val)
else:
    minNode = minValueNode(root.right)
    root.val = minNode.val
    root.right = remove(root.right, minNode.val)
return root
